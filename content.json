[{"title":"注解","date":"2017-02-10T01:04:38.000Z","path":"2017/02/10/注解/","text":"元注解 ： 修饰其他注解 @Target 修饰的对象范围：packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。 作用：用于描述注解的使用范围 例如 @Target(ElementType.METHOD) 限定这个注解只能注解方法 再比如 @Target(ElementType.PARAMETER) 限定了这个注解只能注解方法参数 CONSTRUCTOR:用于描述构造器 FIELD:用于描述域 LOCAL_VARIABLE:用于描述局部变量 METHOD:用于描述方法 PACKAGE:用于描述包 PARAMETER:用于描述参数 TYPE:用于描述类、接口(包括注解类型) 或enum声明 @Retention 定义了该 Annotation 被保留的时间长短：某些 Annotation 仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响 class 的执行，因为Annotation 与 class 在使用上是被分离的）。使用这个meta-Annotation 可以对 Annotation 的“生命周 期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） SOURCE:在源文件中有效（即源文件保留） CLASS:在class文件中有效（即class保留） RUNTIME:在运行时有效（即运行时保留） 自定义注解 通过元注解注解这个注解的使用范围，保留时间 public 修饰 @interface 返回值为基本参数类型 如果只有一个参数最好用value 注解的值获取 方法1： T getAnnotation(Class annotationClass): 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。 方法2：Annotation[] getAnnotations():返回该程序元素上存在的所有注解。 方法3：boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass):判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false. 方法4：Annotation[] getDeclaredAnnotations()：返回直接存在于此元素上的所有注释。与此接口中的其他方法不同，该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 注解的作用还需要多看 多练习，还没有形成系统的概念","tags":[{"name":"java","slug":"java","permalink":"http://sidongyu.com/tags/java/"}]},{"title":"日常记录","date":"2017-02-09T08:34:45.000Z","path":"2017/02/09/日常记录/","text":"Airbnb炫酷的动画 AE做成动画装换成json文件（Bodymovin插件），json文件放到app/src/main/assets 目录下面 引用 Lottie 开源库 &lt;com.airbnb.lottie.LottieAnimationView android:id=&quot;@+id/animation_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:lottie_fileName=&quot;hello-world.json&quot; app:lottie_loop=&quot;true&quot; app:lottie_autoPlay=&quot;true&quot; /&gt; studio 技巧 分屏显示 右键主屏幕的选项卡（tab）选择 Split Vertically / Horizontally 现在改成alt+v alt+h 关闭当前tap ctrl + f4 close others = ctrl + shift + Q close all = ctrl + shift + S 拓展选中 = ctrl + W 快速选中小括号 大括号种的内容 左一个tab = alt + ← 右一个tab = alt + → 隐藏所有窗口 = cmd + shift + F12 不常用 以上键位都是由我自己定的键位 如果需要 自己到 setting–keymap里面设置 轻量级的路由 LiteRouter 什么是路由 ： 不同的请求地址会交给路由处理来转发给相应的控制器处理，所以说路由就可以在转发前修改转发地址，你可以在这上面大作文章。 适用于团队协作开发 原创作者的灵感：App端开发和后台开发就是独立的，他们是如何相互独立又互相配合的呢 回顾 Intent的flags 巧妙运用位运算符 不同的 flag 对应不同的二进制位上面的1，也就是十进制数的1248 当他们坐 |（或）的操作时，哪一个flag参与了 | 的操作，相应的位置上面就会使 1 ，这就能够标记到了 到底都有哪一个flag 同理的老鼠问题 有1000桶酒，其中1桶有毒。而一旦吃了，毒性会在1周后发作。现在 我们用小老鼠做实验，要在1周后找有1000桶酒，其中1桶有毒。而一旦吃了，毒性会在1周后发作。现在我们用小老鼠做实验，要在1周后找出那桶毒酒，最少需要多少老鼠？（老鼠的使用量越少越好，注意，毒性1周后才会发作，而且一周后必 须出结果，所以时间紧迫） A、1只B、10只C、100只D、1000只 答案10只老鼠按顺序排好，每桶酒按照编号转换成二进制，给相应位置上是1的老鼠喝。最后按死掉的老鼠是哪几只，然后排成二进制，再转成十进制就是第几桶酒。比如：第70桶酒，70转换成二进制就是0001000110，那么就给第四、八、九只老鼠喝。如果最后死掉第三、七、八只老鼠，那么就是0010001100，转换成十进制就是140，即140桶酒有毒。(来自百度知道)1000 装换成 2 进制 位数最多位 10位每一个老鼠对应相应位置上面的 1","tags":[{"name":"笔记","slug":"笔记","permalink":"http://sidongyu.com/tags/笔记/"}]},{"title":"dialog从底部弹出来","date":"2017-01-04T07:39:36.904Z","path":"2017/01/04/android/diolog从底部弹出/","text":"先自定义dialog，在oncreat方法中加上如下代码 @Override protected void onCreate(Bundle bundle) { super.onCreate(bundle); getWindow().setGravity(Gravity.BOTTOM); //显示在底部 WindowManager m = getWindow().getWindowManager(); Display d = m.getDefaultDisplay(); WindowManager.LayoutParams p = getWindow().getAttributes(); p.width = d.getWidth(); //设置dialog的宽度为当前手机屏幕的宽度 p.height = (int) (d.getHeight() / 2.7);//设置当前dialog的高度是屏幕的一半 getWindow().setWindowAnimations(R.style.dialogstyle); // 添加动画 getWindow().setAttributes(p); } - 动画 ` &lt;style name=&quot;dialogstyle&quot; parent=&quot;android:Animation&quot;&gt; &lt;item name=&quot;@android:windowEnterAnimation&quot;&gt;@anim/dialog_enter&lt;/item&gt; &lt;item name=&quot;@android:windowExitAnimation&quot;&gt;@anim/dialog_exit&lt;/item&gt; &lt;/style&gt; ` - 在res下面创建anim文件夹 ` &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;400&quot; android:fromYDelta=&quot;100%p&quot; /&gt; &lt;/set&gt;` enter ` &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;translate android:duration=&quot;400&quot; android:toYDelta=&quot;100%p&quot; /&gt; &lt;/set&gt;` exit 一开始我以为就这么简单的事情，结果一显示就傻了，还有不贴边我就百度查啊查的，终于找到解决办法 在构造方法中给dialog加上自己的stylepublic BottomScrollDialog(Context context) { super(context, R.style.my_dialog); requestWindowFeature(Window.FEATURE_NO_TITLE); super.setContentView(view); } style代码&lt;style name=&quot;my_dialog&quot;&gt; &lt;item name=&quot;android:windowNoTitle&quot;&gt;true&lt;/item&gt; &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;true&lt;/item&gt; &lt;/style&gt;","tags":[{"name":"android","slug":"android","permalink":"http://sidongyu.com/tags/android/"}]},{"title":"calendar判断 long时间是否是本周","date":"2017-01-03T06:26:22.343Z","path":"2017/01/03/android/时间工具类判断是否是本周/","text":"工具类 直接上代码 别人的代码上面做了一些小改动。适合自己的项目吧 public class DateUtils { /** * 判断所给时间是否是本周 */ public static boolean isThisWeek(long time) { Calendar calendar = Calendar.getInstance(); int currentWeek = calendar.get(Calendar.WEEK_OF_YEAR); int currentDay_of_Year = calendar.get(Calendar.DAY_OF_YEAR); calendar.setTime(new Date(time)); int paramWeek = calendar.get(Calendar.WEEK_OF_YEAR); int paramDay_of_Week = calendar.get(Calendar.DAY_OF_WEEK); int paramDay_of_Year = calendar.get(Calendar.DAY_OF_YEAR); if (paramWeek == currentWeek) { if (paramDay_of_Week == 1) {//如果是周日 return false; } return true; } if (currentWeek-paramWeek =1 &amp;&amp; paramDay_of_Week == 1) { return true; } // 中国一周的开始是星期一 外国一周的开始是星期二，所以代码是外国人写的 return false; } //判断选择的日期是否是今天 public static boolean isToday(long time) { return isThisTime(time,&quot;yyyy-MM-dd&quot;); } //判断选择的日期是否是本月 public static boolean isThisMonth(long time) { return isThisTime(time,&quot;yyyy-MM&quot;); } private static boolean isThisTime(long time,String pattern) { Date date = new Date(time); SimpleDateFormat sdf = new SimpleDateFormat(pattern); String param = sdf.format(date);//参数时间 String now = sdf.format(new Date());//当前时间 if(param.equals(now)){ return true; } return false; } }","tags":[{"name":"android","slug":"android","permalink":"http://sidongyu.com/tags/android/"}]},{"title":"greenDao使用","date":"2017-01-02T16:00:00.000Z","path":"2017/01/03/android/greendao使用/","text":"greenDao网上关于greendao一大堆，什么内存好呀，什么速度快啊。。。感觉都是原文翻译，我是感觉没有想象中的那样困难 - 第一步 配置project曾的build.gradlebuildscript { repositories { jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:2.2.1&apos; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.1.0&apos; classpath &apos;com.neenbedankt.gradle.plugins:android-apt:1.8&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } } allprojects { repositories { jcenter() } } task clean(type: Delete) { delete rootProject.buildDir } 第二步 配置自己项目 apply plugin: &apos;com.android.application&apos; apply plugin: &apos;org.greenrobot.greendao&apos; //这个要有 使用插件的，会自动生成管理类 android { compileSdkVersion 25 buildToolsVersion &quot;25.0.0&quot; defaultConfig { applicationId &quot;com.snailf.ga.saccountbook&quot; minSdkVersion 15 targetSdkVersion 25 versionCode 1 versionName &quot;1.0&quot; testInstrumentationRunner &quot;android.support.test.runner.AndroidJUnitRunner&quot; } buildTypes { release { minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; } } greendao { schemaVersion 4 //数据库版本 targetGenDir &apos;src/main/java&apos;// DaoMaster DaoSession Dao文件创建的地方 最好放在/main/java下，会报找不到文件错误 } repositories { flatDir { dirs &apos;libs&apos; } } } dependencies { compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) compile &apos;com.alibaba:fastjson:1.2.11&apos; compile &apos;com.android.support:appcompat-v7:25.0.0&apos; compile &apos;org.greenrobot:greendao:3.1.0&apos; //添加依赖greendao compile &apos;com.jakewharton:butterknife:7.0.0&apos; compile &apos;com.android.support:design:25.0.0&apos; compile &apos;com.android.support:support-v4:25.0.0&apos; compile(name: &apos;WheelPicker&apos;, ext: &apos;aar&apos;) } 第三步 编写bean类 @Entity //生成session和dao的标识 ，没有他就不会生成 public class AccountInfo { @Id(autoincrement = true)//主键 自动增长 private Long id; //剩下的都是一些 平平常常的字段 @Property(nameInDb = &quot;ACCOUNTTYPE&quot;) private String accountType; @Property(nameInDb = &quot;AMOUNT&quot;) private long amount; @Property(nameInDb = &quot;TYPE&quot;) private int type; @Property(nameInDb = &quot;DATE&quot;) private long date; @Property(nameInDb = &quot;REMARK&quot;) private String remark; @ToOne(joinProperty = &quot;id&quot;)//一对一 根据id查询另外一个数据库 private BaseType baseType; } 第四步 rebuild project，这下你就可以看到生成session和 dao了 rebuild之后会生成构造方法和setter 俺的 getter方法。如果想要修改字段的类型，或者增加字段，那么就把生成的那些东西，都删了，然后 加上自己想加的，改了自己想改的，重新rebuild，但是这样之前保存的数据就没了。。。 第五步 创建数据库manager public class DateBaseDaoManager { private final static String dbName = &quot;account_db&quot;; private static DateBaseDaoManager mInstance; private DaoMaster.DevOpenHelper openHelper; private Context context; public DateBaseDaoManager(Context context) { this.context = context; openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); } /** * 获取单例引用 * * @param context * @return */ public static DateBaseDaoManager getInstance(Context context) { if (mInstance == null) { synchronized (DateBaseDaoManager.class) { if (mInstance == null) { mInstance = new DateBaseDaoManager(context); } } } return mInstance; } /** * 获取可读数据库 */ private SQLiteDatabase getReadableDatabase() { if (openHelper == null) { openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); } SQLiteDatabase db = openHelper.getReadableDatabase(); return db; } /** * 获取可写数据库 */ private SQLiteDatabase getWritableDatabase() { if (openHelper == null) { openHelper = new DaoMaster.DevOpenHelper(context, dbName, null); } SQLiteDatabase db = openHelper.getWritableDatabase(); return db; } /========================================收入类型增删改查======================= /** * 插入一条 type */ public long insertType(BaseType baseType){ return getTypeDao().insert(baseType); } /** * 插入或者修改一条 type */ public long insertOrUpdateType(BaseType baseType){ return getTypeDao().insertOrReplace(baseType); } /** * 删除一条 type */ public void delType(BaseType baseType){ getTypeDao().delete(baseType); } /** * 查询所有的 type */ public List&lt;BaseType&gt; queryTypeList(){ return getTypeDao().queryBuilder().list(); } //================================收支信息的增删改查============================ /** * 查询 账单 通过id */ public AccountInfo queryOrderById(long id) { if (!TextUtils.isEmpty(id + &quot;&quot;)) { return getOrderDao().load(id); } return null; } /** * 插入或者修改一条 收支信息 */ public long insertOrUpdateOrder(AccountInfo accountInfo){ return getOrderDao().insertOrReplace(accountInfo); } /** * 插入 收支信息 */ public long insertOrder(AccountInfo accountInfo){ return getOrderDao().insert(accountInfo); } /** * 删除一条 收支信息 */ public void delOrder(AccountInfo accountInfo){ getOrderDao().delete(accountInfo); } /** * 查询所有的 收支信息 */ public List&lt;AccountInfo&gt; queryOrderList(){ return getOrderDao().queryBuilder().list(); } //====================================获取数据操作的dao===================================== /** * 收支信息的dao */ public BaseTypeDao getTypeDao() { DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); return daoSession.getBaseTypeDao(); } /** * 收支信息的dao */ public AccountInfoDao getOrderDao() { DaoMaster daoMaster = new DaoMaster(getWritableDatabase()); DaoSession daoSession = daoMaster.newSession(); return daoSession.getAccountInfoDao(); } } ====================greendao3.0 不像之前那样配置麻烦了，之前还有那样，还要这样的，看着就烦人，就一代而过了================","tags":[{"name":"android","slug":"android","permalink":"http://sidongyu.com/tags/android/"}]},{"title":"强大的SpannableString","date":"2016-12-20T16:00:00.000Z","path":"2016/12/21/android/SpannableStringBuilder/","text":"SpannableString中最重要的方法就是 setSapan()方法了，有一个参数what是这个方法的精髓。what： BackgroundColorSpan : 文本背景色 ForegroundColorSpan : 文本颜色 MaskFilterSpan : 修饰效果，如模糊(BlurMaskFilter)浮雕 RasterizerSpan : 光栅效果 StrikethroughSpan : 删除线 SuggestionSpan : 相当于占位符 UnderlineSpan : 下划线 AbsoluteSizeSpan : 文本字体（绝对大小） DynamicDrawableSpan : 设置图片，基于文本基线或底部对齐。 ImageSpan : 图片 RelativeSizeSpan : 相对大小（文本字体） ScaleXSpan : 基于x轴缩放 StyleSpan : 字体样式：粗体、斜体等 SubscriptSpan : 下标（数学公式会用到） SuperscriptSpan : 上标（数学公式会用到） TextAppearanceSpan : 文本外貌（包括字体、大小、样式和颜色） TypefaceSpan : 文本字体 URLSpan : 文本超链接 ClickableSpan : 点击事件 TextAppearanceSpan(String family, int style, int size, ColorStateList color, ColorStateList linkColor) family: monospace serif 一般都选这个 sans-serif style: Typeface.NORMAL 正常 Typeface.BOLD 加粗 Typeface.ITALIC 斜体 Typeface.BOLD_ITALIC 加粗斜体 size 文字大小 color 字体颜色selector context.getColorStateList(R.color....) M以上的 ColorState.createFromXml(context.getResources(),context.getResources().getXml(R.color.selector_apperarance_span) linkColor","tags":[{"name":"android","slug":"android","permalink":"http://sidongyu.com/tags/android/"}]},{"title":"司雨烂片---蚂蚱","date":"2016-12-12T16:00:00.000Z","path":"2016/12/13/photo/mazha/","text":"","tags":[{"name":"照片","slug":"照片","permalink":"http://sidongyu.com/tags/照片/"}]},{"title":"司雨烂片---昙花绽放","date":"2016-12-12T16:00:00.000Z","path":"2016/12/13/photo/tflower_1/","text":"","tags":[{"name":"照片","slug":"照片","permalink":"http://sidongyu.com/tags/照片/"}]},{"title":"司雨烂片---昙花花蕊","date":"2016-12-12T16:00:00.000Z","path":"2016/12/13/photo/tflowercenter/","text":"","tags":[{"name":"照片","slug":"照片","permalink":"http://sidongyu.com/tags/照片/"}]}]